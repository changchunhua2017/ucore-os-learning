# Lab 8

## 知识点

这些是与本实验有关的原理课的知识点：

* 管道
* 虚拟文件系统框架
* 文件描述符
* 目录等
* inode、打开的文件等结构体
* inode缓存

此外，本实验还涉及如下知识点：

* 简单文件系统
* ucore特定的文件系统架构

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 其他进程间通信机制，例如信号、消息队列和共享内存
* RAID
* 磁盘调度算法
* 磁盘缓存
* IO

## 练习0

首先，需要对之前的代码进行微小的修改：

1. `alloc_proc`加入对新增字段的初始化，由于我使用`memset`初始化，不需要修改
2. `do_fork`中，使用`copy_files`复制进程打开的文件

## 练习1

这个练习需要实现SFS文件系统层的`sfs_io_nolock`函数。实现过程中，需要用到以下辅助函数或函数指针：

* `sfs_bmap_load_nolock`：根据相对于文件而言的块号，获得inode号。
* `sfs_buf_op`：带缓冲区的块操作，可以用来进行对齐或非对齐的块读写操作；但是，对齐的操作不应当用此函数，否则会有多余的拷贝操作。根据读写操作的不同，分别指向`sfs_wbuf`或`sfs_rbuf`。
* `sfs_block_op`：直接的块操作，可以用来进行对齐的块读写操作。根据读写操作的不同，分别指向`sfs_wblock`或`sfs_rblock`。

根据要实现的`sfs_io_nolock`函数的输入参数，可以计算出读写文件操作的开始和结束位置，它们可能是没有按照块大小对齐的，为此需要特殊处理。我的处理方案分两大类情况：

*第一类情况*

开始和结束位置中有一个值没有按照块大小对齐，并且开始和结束在同一块内。

对于这种情况，只须调用`sfs_bmap_load_nolock`得到块号，然后使用`sfs_buf_op`完成非对齐的操作。

*第二类情况*

不是上述情况的其他情况，例如开始和结束位置不在同一块。

可以将开始到结束的区间分为三段：

1. 首部非对齐的部分
2. 中间对齐的部分
3. 尾部非对齐的部分

对于首部非对齐的部分以及尾部非对齐的部分，处理方法类似于第一类情况。

对于中间对齐的部分，对于其中每一个块，调用`sfs_bmap_load_nolock`得到块号后直接调用`sfs_block_op`完成对齐的操作。注意，虽然`sfs_block_op`支持一次操作多个块，但这里对于文件的操作不能一次调用`sfs_block_op`完成所有块的操作，因为相对于文件连续的块不一定在下层存储设备上连续，即块号不一定连续，故对于每一个块需要重新调用`sfs_bmap_load_nolock`得到块号。

注意，实现时还需要考虑出错处理。

与参考答案对比，我的思路和参考答案一致，但是参考答案的实现更简洁明了。

### 管道机制的设计

#### 创建

首先，是管道的创建，即`pipe`系统调用的实现。

为创建管道，可以先创建一个类型为管道的inode，操作虚表配置为如下说明的读写操作，同时要为管道准备好缓冲区。然后，创建两个“打开的文件”结构体（`file`结构体）和相应的文件描述符，一个设置为只读，另外一个设置为只写，都绑定到此inode。最后，把这两个文件描述符返回给用户。一种实现是用户提供一个数组，内核填写为两个文件描述符。

#### 读

读的实现也就是inode的`read`函数的实现，记需要读的长度为`r`（代表read），缓冲区内的可用数据长度为`d`（代表data），则分为以下情况。

**情况1** `r <= d`

从缓冲区移动长度为`r`的数据到用户空间，然后令`d = d - r`。返回值设定为`r`。

唤醒写者（若有）。

**情况2** `r > d`且写者未关闭管道

从缓冲区移动长度为`d`的数据到用户空间，然后令`d = 0`、令`r = r - d`、唤醒写者（若有），然后将当前进程变为睡眠态，直到写者写入数据后被唤醒，被唤醒后再次开始循环。直到满足`r <= d`，接着按照情况1处理，但返回值设定为最初的`r`。循环途中若写者关闭了管道，则立即返回，返回值设定为当前已经读到的数据的长度。

**情况3** `r > d`且写者关闭了管道

从缓冲区移动长度为`d`的数据到用户空间，然后令`d = 0`。返回值设定为`d`。

注意，读者关闭管道时要唤醒写者（若有）。

#### 写

读的实现也就是inode的`write`函数的实现，记需要写的长度为`w`（代表write），缓冲区内的可用缓冲区长度为`b`（代表buffer），则分为以下情况。

**情况1** `w <= b`且读者未关闭管道

从用户空间拷贝长度为`w`的数据到缓冲区，然后令`b = b - w`。返回值设定为`w`。

唤醒读者（若有）。

**情况2** `w > b`且读者未关闭管道

从用户空间拷贝长度为`b`的数据到缓冲区，然后令`b = 0`、令`w = w - b`、唤醒读者（若有），然后将当前进程变为睡眠态，直到读者读出数据后被唤醒，被唤醒后再次开始循环。直到满足`w <= b`，接着按照情况1处理，但返回值设定为最初的`w`。循环途中若读者关闭了管道，则立即返回，返回值设定为当前已经复制到缓冲区的数据的长度。

**情况3** 读者关闭了管道

直接返回0。

注意，写者关闭管道时要唤醒读者（若有）。

#### 约束

上面的实现其实隐含了如下几点特殊的约束条件：

* `b + d = 缓冲区大小`
* 不能同时有读者和写者处于睡眠，有则说明出现了死锁

顺便一提，管道的实现和stdin设备的实现非常类似。此外，根据上面的描述以及管道的实际意义，这其实是一个生产者—消费者问题。

## 练习2

这个练习有两大部分：读取并解析ELF格式的可执行文件映像、在用户态栈上构建命令行参数。

为了实现`load_icode`来读取并解析ELF格式的可执行文件映像，主体逻辑部分可以复用Lab 7中的代码，只是把其中对于`binary`字节数组的拷贝操作改为调用`load_icode_read`进行读文件操作。

接着，需要在用户态栈上填充命令行参数，显然，用户代码的参数不能存放于内核的空间。通过阅读并分析`user/libs/initcode.S`以及`user/libs/umain.c`，可以知道在运行`user/libs/initcode.S`的代码之前，栈上需要有这样的布局：

```
| High Address |
----------------
|   Argument   |
|      n       |
----------------<-+
|   Argument   |  |
|    n - 1     |  |
----------------<-+-+
|     ...      |  | |
----------------  | |
|   Argument   |  | |
|      2       |  | |
----------------<-+-+-+
|   Argument   |  | | |
|      1       |  | | |
----------------<-+-+-+-+
|    padding   |  | | | |
----------------  | | | |
|   null ptr   |  | | | |
----------------  | | | |
|  Ptr Arg n   |--+ | | |
----------------    | | |
| Ptr Arg n - 1|----+ | |
----------------      | |
|     ...      |      | |
----------------      | |
|  Ptr  Arg 2  |------+ |
----------------        |
|  Ptr  Arg 1  |--------+
----------------
|  Arg  Count  | <-- user esp
----------------
| Low  Address |
```

其中，参数内容长度不确定，参数指针和参数个数变量均为4字节。最后一个参数指针的后面是一个标志结束的空指针，参数指针开始位置根据约定和性能考虑，需要4字节对齐，所以空指针后面有4字节对齐的填充（padding）。

实现时，只需要将内核空间的参数拷贝到用户栈上、压入填充、压入空指针、压入对应的参数指针，最后压入参数个数即可。此外，由于之前加载了新的页目录基址寄存器`cr3`，这里可以直接使用用户态的虚拟地址进行访问。

与参考答案对比，处理ELF部分我和答案实现完全一致，对于在用户态栈上填充命令行参数部分，我认为我的实现思路更清晰，代码风格更优美。

### 硬链接机制的设计

硬链接的设计非常简单，只需要创建时将目录项的名字设定为指定的名字，目录项的inode号设置为目标文件等的inode号即可。此外，还需要增加目标inode的引用计数。

删除时，同样需要减少目标inode的引用计数，其引用计数归零后，也需要清除目标inode及其数据块。

其他操作均不需要变化，也不需要修改数据结构。

需要注意的是，硬链接不能支持目录的链接，因为这会引起一些很不好的问题。

### 软链接机制的设计

软链接也叫做符号链接，实际上就是一类特殊类型的文件，文件的数据为指向的目标文件或目录等的路径。

创建时，只需将inode的类型设置为符号链接，文件内容（数据）设置为目标路径字符串。

删除操作和普通文件实现一致。

此外，在各类`lookup`操作时要考虑软链接的作用，需要真正处理软链接的目标而不是软链接本身。

# 祝贺我通过自己的努力，完成了ucore OS lab1 - lab8！